
# Python libraries
import argparse
import logging
import os
import sys

from datetime import datetime

from immunopepper.mode_build import mode_build
from immunopepper.mode_samplespecif import mode_samplespecif
from immunopepper.mode_cancerspecif import mode_cancerspecif
from immunopepper.mode_pepQuery import mode_pepquery

def _add_general_args(parser):
    general = parser.add_argument_group('GENERAL')
    general.add_argument("--verbose", type=int, help="specify output verbosity (0 - warn, 1 - info, 2 - debug) [1]", required=False, default=1)

def get_subparsers(parser):

    """
    Creates the different subparsers and returns them to fill them with arguments.

    Parameters
    ----------
    parser : argparse.ArgumentParser. Main parser of immunopepper

    """

    subparsers = parser.add_subparsers(help='Running modes', metavar='{build, samplespecif, cancerspecif, mhcbind, pepquery}')

    #I will create the different subparsers
    parser_build = subparsers.add_parser('build', help='Core part of ImmunoPepper. Traverses the input splice graph and generates all possible peptides/kmers.')
    parser_samplespecif = subparsers.add_parser('samplespecif', help='Performs removal of the annotation to make the kmer list sample specific')
    parser_cancerspecif = subparsers.add_parser('cancerspecif', help='Performs differential filtering against a panel of normal samples')
    parser_mhcbind = subparsers.add_parser('mhcbind', help='Perform MHC binding prediction with a wrapper for MHCtools')
    parser_pepquery = subparsers.add_parser("pepquery", help="Perform peptide validation with a wrapper for the tool PepQuery")
    return parser_build, parser_samplespecif, parser_cancerspecif, parser_mhcbind, parser_pepquery

def get_build_parser(parser):

    """
    Function that creates the subparser for the build mode with its arguments
    """

    required = parser.add_argument_group('Mandatory arguments')
    required.add_argument("--output-dir", help="absolute path of the output directory. All output files generated by immunopepper will be saved in this directory.", required=True, default='output')
    required.add_argument("--ann-path", help="absolute path for the annotation file. Accepted file formats: *.gtf*, *.gff* and *.gff3*. Annotation files can be downloaded from various databases such as `GENCODE <https://www.gencodegenes.org/human/>`_ ", required=True)
    required.add_argument("--splice-path", help="absolute path of the input `SplAdder <https://github.com/ratschlab/spladder>`_ splice graph.", required=True)
    required.add_argument("--ref-path", help="absolute path of the reference genome file in FASTA format. Reference Please ensure that the reference genome is compatible with the gene annotation file being used. For example, if the annotation file is based on GRCh38, the reference genome should also be based on GRCh38. You can check `here <https://www.gencodegenes.org/human/releases.html>`_ gencode annotation releases and their corresponding major genome assembly releases. For example, if you decide to use genome assembly version GRCh38.p13, you need to use its compatible annotation file from release 43 in GENCODE.", required=True)
    required.add_argument("--kmer", type=int, help="length of the kmers for kmer output.", required=True, default=9)

    submodes = parser.add_argument_group('Submodes parameters', 'Commands for conceptual information about the processing.')
    submodes.add_argument("--pep-length", type=int, help="length of the peptides for peptide output.", required=False, default=100)
    submodes.add_argument("--pep-step", type=int, help="step size for the peptides. It defines the overlap between two consecutive peptides. For example, if --pep-length is 27 and --pep-step is 9, the peptides will overlap by 18 aminoacids.", required=False, default=30)
    submodes.add_argument("--libsize-extract",help="This option generates library sizes and gene quantifications and skip neontigen generation.",action="store_true", required=False, default=False)
    submodes.add_argument("--all-read-frames", help="This option enables the exhaustive translation and to study all possible reading frames instead of just the ones present in the annotation file.", action="store_true", required=False, default=False)
    submodes.add_argument("--count-path", help="Absolute path for the second output of `SplAdder <https://github.com/ratschlab/spladder>`_ containing the graph expression quantification. If provided, expression quantification of genes will take place. **Format:** hdf5.", required=False, default=None)
    submodes.add_argument("--output-samples", nargs='+', help="List of sample names to output. **Note:** *Names should match the file name of the splice graphs. If not provided all samples are processed and program runs faster.*", required=False, default=[])
    submodes.add_argument("--heter-code", type=int, help="It specifies the heterozygous allele.", default=0, choices = ['0', '2'])  #TODO: Add more info about this parameter?

    parameters = parser.add_argument_group('Technical parameters' , 'Commands for optimization of the software.')
    parameters.add_argument("--compressed", help="Compress output files", action="store_true", default=True)
    parameters.add_argument("--parallel", type=int, help="Number of cores to be used.", required=False, default=1)
    parameters.add_argument("--batch-size", type=int, help="Number of genes to be processed in each batch. If bigger batches are selected, the program will be faster, but it will require more memory.", default=1000)
    parameters.add_argument("--pickle-samples", nargs='+', help="List of samples to be pickled. Needed if `--use-mut-pickle` is included. It will create intermediate files containing mutation information of the selected samples. This command is useful because mutation/variant information needs to be parsed in every run of the software, which is a time-consuming operation. By pickling the mutations, when mutation information is needed, it will be directly loaded from the intermediate pickled files instead than from the original mutation files provided under `--somatic` and `--germline`. This will speed up software re-runs. When dealing with large cohorts, this command is useful to select exactly what files should be pickled. If not provided, all the samples passed in `--mutation-sample` will be pickled. Names should match the sample names of the graph/counts files but an equivalence can be set using `--sample-name-map` from mutation parameters.", required=False, default=[])

    subset = parser.add_argument_group('Subset parameters', 'Commands to select a subset of the genes to be processed.')
    subset.add_argument("--process-chr", nargs='+',help="List of chromosomes to be processed. If not provided all chromosomes are processed. The chromosomes names should be provided in the same format as in FASTA and annotation files. For annotations downloaded from GENCODE, this format is **chrX**, X being the chromosome number.", required=False, default=None)
    subset.add_argument("--complexity-cap", type=int, help="Development parameter that specifies the maximum edge complexity of the graph to be processed. It can help processing samples with very complex splicing patterns. A cap of 4000 was empirically determined, however, parameter values need to be adjusted based on computational ressources. If not provided all graphs are processed.", required=False, default=None)
    subset.add_argument("--genes-interest", help="Genes to be processed. **Format:** Input is a csv file containing a gencode gene id per line, with no header. **Technical note:** The gencode gene id must match the gencode gene ids of the splice graph. Therefore, the format for this argument must match the format of the *gene_id* field of the annotation file used in the build mode of SplAdder and passed under `--ann-path` in immunopepper. If not provided, all genes are processed.", required=False, default=None)
    subset.add_argument("--start-id", type=int, help="Id of the first gene in the splice graph to be processed. If not provided, all genes are processed.", required=False, default=0)
    subset.add_argument("--process-num", metavar='N', type=int, help="Number of genes to be processed. If provided, the first process-num genes are processed.", required=False, default=0)

    outputs = parser.add_argument_group('Output parameters',  'Commands to select output formatting and filtering.')
    outputs.add_argument("--skip-annotation", help='This option allows to skip the generation of a background kmer and peptide files solely derived from the isoforms of the annotation file', action="store_true", default=False)
    outputs.add_argument("--output-fasta", help="This option allows to output the foreground peptides in fasta format, in addition to the tabular metadata file.",  action="store_true", required=False, default=False)
    outputs.add_argument("--force-ref-peptides", help="This option forces the output of mutated peptides in case of sequence redundance with the reference. The reference here refers to the peptides without any mutations or variant application.", action="store_true", default=False)
    outputs.add_argument("--filter-redundant", help="If set to true, a redundancy filter will be applied to the exon list. If two or more exons span the same juction, their coordinates will be combined so that the longest spanning combination is kept.", action="store_true", required=False, default=False)
    outputs.add_argument("--kmer-database", help="Absolute path of a file containing kmers in one column, without header. If the kmers contained in this database contain the aminoacid isoleucine (I), it will be converted into leucine (L). A file from uniprot or any other standard library can be provided. The kmers provided in this file will not be output if found in the foreground peptides. Please note that if a standard proteome is downloaded from an online resource the proteins should be cut into the kmers length selected under `--kmer`.", required=False, default=None)
    outputs.add_argument("--gtex-junction-path", help="Absolute path of whitelist junction path. The junctions of this file will be the only ones output from the tool. \n **Format:** hdf5 file with 'chrm', 'pos' and 'strand' as keys. *'Chrm'* contains the chromosome name in the same format as in the annotation. *'pos'* contains coordinates. The coordinates are end_e1 and start_e2. This means that end_e1 > start_e2 if strand is '-' and end_e1 < start_e2 if strand '+'. *strand* will be either '-' or '+'. \n \n **Pipeline relevance**: When a whitelist file is provided, the field 'isJunctionList' in the metadata output file will contain a 1 if the junction is contained in this list, and 0 otherwise.", required=False, default=None)
    parameters.add_argument("--disable-concat", help="Disable the generation of kmers from combinations of more than 2 exons. In this mode, any kmer shorter than `--kmer` will be discarded. Without this option, the generation of kmers from 3 exons is allowed, ensuring that kmers generated from shorter exons are kept. The --disable-concat option can be used to focus on higher confidence k-mers (decreases sensitivity) or to speed-up run time." , action="store_true", default=False)
    parameters.add_argument("--disable-process-libsize", help="This option generates the libsize file.", action="store_true", default=False)


    mutation = parser.add_argument_group('Mutation parameters',  'Commands to add somatic and germline mutation information.')
    mutation.add_argument("--mutation-sample", help="Sample id of the files to which mutations are added. The ids should match the graphs/counts names, but an equivalence can be set with --sample-name-map.", required=False, default=None)
    mutation.add_argument("--germline", help="Absolute path of the germline mutation file. **Format:** VCF, MAF or h5.", required=False, default='')
    mutation.add_argument("--somatic", help="Absolute path of the somatic mutation file. **Format:** VCF, MAF or h5.", required=False, default='')
    mutation.add_argument("--sample-name-map", help="Name mapping to sample names from graphs/counts files. **Format:** No header. Two columns: *[name of count/graphs file \t name of mutation/pickle file]*. Three columns: *[name of count/graphs file \t name of germline file \t name of somatic file]*.", required=False, default=None)
    mutation.add_argument("--use-mut-pickle", help="This option introduces an intermediate saving of a pickled mutation dictionary to speed up software re-runs. This command is useful because mutation/variant information needs to be parsed in every run of the software, which is a time-consuming operation. By pickling the mutations, when mutation information is needed, a re-run will load it from the intermediate files instead than from the original mutation files provided under `--somatic` and `--germline`.", action="store_true", default=False)

    _add_general_args(parser)

    return parser

def get_samplespecif_parser(parser):
    required = parser.add_argument_group('Mandatory arguments')
    required.add_argument("--annot-kmer-files", nargs='+', help="List of absolute paths to the annotation kmer files. The files should have the name **\[mut_mode\]_annot_kmer.gz**.", required=True, default='')
    required.add_argument("--output-dir", help=' Path to the output directory.', required=True)
    required.add_argument("--junction-kmer-files", nargs='+', help="Absolute path to the folder containing the foreground kmers. The possible folders one can use for this mode are: **\[mut_mode\]_graph_kmer_JuncExpr** or **\[mut_mode\]_graph_kmer_SegmExpr**.",required=True, default='')
    required.add_argument("--bg-file-path", help="Absolute path to the intermediate pooled annotation file. This file is the set of unique kmers in `--annot-kmer-files` files. If the file is not provided it will be generated. In order to be generated one needs to provide the folder and the file name where the file will be saved. **Note:** It should be a non existent folder. Format: One column with header 'kmer'.", required=True, default='')
    required.add_argument("--output-suffix", help="Suffix to be appended to the filtered `--junction-kmer-files`, e.g. samplespecif", required=True)

    optional = parser.add_argument_group('Optional argument')
    optional.add_argument("--remove-bg", help="This option filters out the kmers in `--bg-file-path` from the `--junction-kmer-files`. Without the option, a flag columnn `is_neo_flag` is introduced in the `--junction-kmer-files` files. The column will contain False if the kmer is in `--bg-file-path` and True otherwise.", action="store_true", required=False, default=False)

    _add_general_args(parser)
    return parser

def get_cancerspecif_parser(parser):
    mandatory = parser.add_argument_group('Mandatory arguments', 'These arguments belong to three main groups: \n\n**Technical parameters:** Due to the heavy amount of data, this mode uses spark. These are parameters to control spark processing \n\n**Input helper parameters:** These parameters are used for parsing the input files by the software \n\n**General output files:** Parameters for the files that are output by the software regardless of the filtering method.')

    mandatory.add_argument("--cores", type=int, help="Technical parameter. Number of cores to use", required=True, default='')
    mandatory.add_argument("--mem-per-core", type=int, help="Technical parameter. Memory required per core", required=True)
    mandatory.add_argument("--parallelism", type=int, help="Technical parameter. Parallelism parameter for Spark Java Virtual Machine (JVM). It is the default number of partitions in RDDs returned by certain transformations. Check `--spark.default.parallelism` `here <https://spark.apache.org/docs/latest/configuration.html>`_ for more information.", required=True)

    mandatory.add_argument("--kmer", help='Input helper parameter. Kmer length', required=True)

    mandatory.add_argument("--output-dir", help="General output file. Absolute path to the output directory to save the filtered data.", required=True, default='')

    technical = parser.add_argument_group('Optional technical parameters', 'Due to the heavy amount of data, this mode uses spark. These are parameters to control spark processing')
    technical.add_argument("--out-partitions", type=int, help="This argument is used to select the number of partitions in which the final output file will be saved. If not provided, the results are saved in a single file", required=False, default=None)
    technical.add_argument("--scratch-dir", help="Os environment variable name containing the cluster scratch directory path. If specified, all the intermediate files will be saved to this directory. If not specified, the intermediate files will be saved to the output directory, specified under `--output-dir`. If the scratch directory is provided, `--interm-dir-norm` and `--interm-dir-cancer` are ignored.", required=False, default='')
    technical.add_argument("--interm-dir-norm", help="Custom scratch directory path to save the intermediate files for the normal samples. If not specified, the intermediate files will be saved to the output directory, specified under `--output-dir`.", required=False, default='')
    technical.add_argument("--interm-dir-canc", help="Custom scratch directory path to save the intermediate files for the cancer samples. If not specified, the intermediate files will be saved to the output directory, specified under `--output-dir`.", required=False, default='')

    input_help = parser.add_argument_group('Optional input helper parameters' , 'These parameters are used for parsing the input files by the software.')
    input_help.add_argument("--ids-cancer-samples", nargs='+', help="List with the cancer sample IDs of interest. The samples should be contained in the input cancer expression matrix, and follow the same format. ", required=False, default='')
    input_help.add_argument("--mut-cancer-samples", nargs='+', help="List of mutation modes corresponding to each cancer sample. They will be used to tag the output files. The list should have the same number of entries as `--ids-cancer-samples`.", choices=['ref', 'somatic', 'germline', 'somatic_and_germline'], required=False, default='')

    inputs = parser.add_argument_group('Optional general input files' , 'Parameters for the input files that are used regardless of the filtering method.')
    inputs.add_argument("--whitelist-normal", help="File containing the whitelist of normal samples. If provided, only the samples in the whitelist will be retrieved and further processed. **Format:** Tab separated file without a header, with a single column containing sample names.", required=False, default=None)
    inputs.add_argument("--whitelist-cancer", help="File containing the whitelist of cancer samples. If provided, only the samples in the whitelist will be retrieved and further processed. **Format:** Tab separated file without a header, with a single column containing sample names.", required=False, default=None)
    inputs.add_argument("--path-cancer-libsize", help="Path for the libsize file of the selected cancer samples.", required=False, default=None)
    inputs.add_argument("--path-normal-libsize", help="Path for the libsize of the selected normal samples.", required=False, default=None)
    inputs.add_argument("--normalizer-cancer-libsize", type=float, help="**Default =** median of the libsize across all input samples. Custom normalization factor for the cancer libsize. Normalization is used to make all the samples comparable and correct for possible biases in data acquisition. The normalization is done according to the following formula: (read count / 75th quantile in sample) * normalizer value.", required=False, default=None)
    inputs.add_argument("--normalizer-normal-libsize", type=float, help="**Default =** median of the libsize across all input samples. Custom normalization factor for the normal libsize. Normalization is used to make all the samples comparable and correct for possible biases in data acquisition. The normalization is done according to the following formula: (read count / 75th quantile in sample) * normalizer value.", required=False, default=None)

    outputs = parser.add_argument_group('Optional general output files', 'Parameters for the files that are output by the software regardless of the filtering method.')

    outputs.add_argument("--output-count", help="Path and name where the intermediate numbers of kmers remaining after each filtering step will be written. If selected, a file will be written containing the number of kmers present after each filtering step. It might slow down the computations. However, it is useful if there is an interest on intermediate filtering steps.", required=False, default='')
    outputs.add_argument("--tag-normals", help="Name for the normal cohort used for filtering. Needed when there are various normal cohorts. It will be added to the final output name in order to identify the normal cohort against which the cancer samples were filtered.", required=False, default='')
    outputs.add_argument("--tag-prefix", help="Prefix used for the output files. It is recommended when there are different conditions being studied.", required=False, default='')

    nrf = parser.add_argument_group('Optional parameters for normal samples filtering', 'Parameters to perform the step 2 of the normal filtering pipeline.')
    nrf.add_argument("--path-normal-matrix-segm", nargs='+', help="Path to the matrix of segment expression of kmers in normal samples.", required=False, default=None)
    nrf.add_argument("--path-normal-matrix-edge", nargs='+', help="Path to the matrix of junction expression of kmers in normal samples.", required=False, default=None)
    nrf.add_argument("--n-samples-lim-normal", type=int, help=" Integer number that sets the number of normal samples in which we need to see any expression to exclude a k-mer from the tumor-associated k-mer set. I.e. if the k-mer expression is > 0 in at least n normal samples.", required=False, default=None)
    nrf.add_argument("--cohort-expr-support-normal", type=float, help="Float that specifies the k-mer expression level (normalized), that if observed in any normal sample, will lead to exclusion for the tumor-associated k-mer set. I.e. if a kmer is found with an expression level higher or equal than this threshold in one or more normal samples it will be considered a normal kmer and excluded as tumor-associated candidate.", required=False, default=None)

    crf = parser.add_argument_group('Optional parameters for cancer samples filtering',  'Parameters to perform the step 2 of the cancer filtering pipeline.')
    crf.add_argument("--sample-expr-support-cancer", type=float, help="Float that sets the expression level (normalized) required in a given cancer sample to be included in the tumor-associated set. I.e. k-mers with an expression higher or equal than this threshold in the cancer sample of interest will included. Cancer samples of interest are provided under --ids_cancer_samples.", default = None, required = False)
    crf.add_argument("--cohort-expr-support-cancer", type=float, help="Float that sets the expression value (normalized) that needs to be observed in at least `--n-samples-lim-cancer` in order to consider a k-mer as tumor-associated. I.e. k-mers with an expression higher than this threshold in at least `--n-samples-lim-cancer` samples will be included. Warning: for each cancer sample of interest, provided under `--ids_cancer_samples`, the expression threshold will be assessed in the cancer cohort, EXCLUDING the sample of interest.", required=False, default=None)

    crf.add_argument("--n-samples-lim-cancer", type=int, help="Integer that sets the the minimum number of cancer samples in which one should see an expression higher than `--cohort-expr-support-cancer` to be included in the tumor-associated set. I.e. k-mers with an expression higher than `--cohort-expr-support-cancer` in at least `--n-samples-lim-cancer` samples will be considered as cancer candidates. Warning: for each cancer sample of interest, provided under `--ids_cancer_samples`, the expression threshold `--cohort-expr-support-cancer` will be assessed in the rest of the cohort, EXCLUDING the sample of interest.", required=False, default=None)
    crf.add_argument("--path-cancer-matrix-segm", nargs='+', help="Path to the cancer matrix containing segment expression from samples belonging to a cohort. The matrix will have the following dimensions: [kmers * samples]. When only the junction overlapping cancer kmers are of interest, the user should provide only `--path-cancer-matrix-edge`, and skip the inclusion of this file.If both matrices are provided, junction expression will be chosen in case there is expression information for the same kmer in both matrices.", required=False, default=None)
    crf.add_argument("--path-cancer-matrix-edge", nargs='+', help="Path to the cancer matrix containing junction expression from samples belonging to a cohort. The matrix will have the following dimensions: [kmers * samples]. When only the junction overlapping cancer kmers are of interest, the user should provide only this file, and skip the inclusion of `--path-cancer-matrix-segm`. If both matrices are provided, junction expression will be chosen in case there is expression information for the same kmer in both matrices.", required=False, default=None)
    crf.add_argument("--cancer-support-union", help="Parameter to choose how the sample specific filtering and the cohort specific filtering are combined. By default, they are combined by choosing the common kmers to both filtering steps, i.e. performing an intersection. By selecting this option, the union of both filtering steps will be performed, i.e. the kmers that pass either the sample specific filtering or the cohort specific filtering will be kept.", action="store_true", required=False, default=False)

    more_backgrounds = parser.add_argument_group('Optional parameters for the addition of additional backgrounds' , 'Parameters to add additional backgrounds that will be removed.')
    more_backgrounds.add_argument("--path-normal-kmer-list", nargs='+', help="List of kmers to be added as part of the normal samples. The kmers provided in this list will be included in the normal background, without having to pass any of the filtering steps for the normal data. Format: It can be either a *tsv* or *parquet* file. If *parquet* is the used format, the file should contain the header 'kmer' in the first column.", required=False, default=None)
    more_backgrounds.add_argument("--uniprot", help="Path to file containing uniprot kmers. The kmers contained in this databased will be assumed to be not novel peptides, and they will be removed from the cancer filtering output. *Note: It is important to kmerize the peptides downloaded from uniprot database into the length specified in `--kmer`*.", required=False, default=None)

    more_filters = parser.add_argument_group('Optional parameters to add additional filters' , 'Parameters to add the additional filters shown in step 1 of both pipelines. ')
    more_filters.add_argument("--filterNeojuncCoord", choices=['C', 'N', 'A'], required=False, default='', help=" This argument will filter the neojunctions, and it will retain only the kmers that are generated from neojunctions. These are peptides whose junction coordinates were not part of the annotation files. Selecting this option means that only those kmers with junctionAnnotated = False will be considered for further filtering. This filter is used in the preprocessing (step 1 of cancer and normal pipelines). If 'C' is selected, the filter is only applied to the cancer sample. If 'N' is selected, the filter is only applied to the normal samples. If 'A' is selected, the filter is applied to both cancer and normal samples.")
    more_filters.add_argument("--filterAnnotatedRF", choices=['C', 'N', 'A'], required=False, default='', help="This argument will only retrieve kmers that were generated from annotated reading frames and discard those that were obtained by reading frame propagation through the graph. By selecting this option, only kmers generated from reading frames present in the annotation are kept. This means that selecting this option means that only those kmers with ReadFrameAnnotated = True will be selected. This filter is used in the preprocessing (step 1 of cancer and normal pipelines). If 'C' is selected, the filter is only applied to the cancer sample. If 'N' is selected, the filter is only applied to the normal samples. If 'A' is selected, the filter is applied to both cancer and normal samples.")

    development = parser.add_argument_group('Optional development parameters')
    development.add_argument("--tot-batches", type=int, help="If selected, the filtering of the background and foreground will be based on hash functions. This parameter will set the total number of batches in which we will divide the foreground and background files to filter, and each of those batches will be assigned a hash value. If `--batch-id` is specified, `--tot-batches` should also be specified.", required=False, default=None)
    development.add_argument("--batch-id", type=int, help="If selected, the filtering of the background and foreground will be based on hash functions. This parameter will set the batch id of the current batch that is being filtered. The batch id should be an integer between 0 and `--tot-batches`. It shows the specific batch that we want to process, out of the `--tot-batches`. If `--batch-id` is specified, `--tot-batches` should also be specified.", required=False, default=None)
    development.add_argument("--on-the-fly", help="Whith this option, all the filtering steps will be done on the fly, without the creation of intermediate files. The creation of intermediate files would speed up the computations in the case where full or partial reruns are planned. An example of a partial rerun would be when several normal and cancer filtering parameters are applied to the same cohort. Choosing not to save intermediate files will trade speed for disk space.", action="store_true", default=False)

    _add_general_args(parser)

    return parser

def get_mhcbind_parser(parser):
    required = parser.add_argument_group('Mandatory arguments')

    required.add_argument("--mhc-software-path", help="Path for the MHC prediction software.", required=True, default=None)
    required.add_argument("--argstring", help="Complete command line for the MHC prediction tool passed as a string. One should include here the command that will be directly passed to the selected MHC tool. The four mandatory arguments are: \n 1.--mhc-predictor: This argument will specify the name of the software tool that will be used. The name should be in the format accepted by the library `mhc_tools <https://github.com/openvax/mhctools>`_ \n \n 2.--output-csv: This argument will contain the path and filename where the MHC prediction tool will save the results. The format of the file should be *.csv*.\n \n 3.--input-peptides-file: This argument will have the path and filename to the file containing the set of kmers on which MHC binding affinity prediction will be performed. The file should have the list of kmers on one column without header. If the user wishes to run MHC prediction on the output of the `cancerspecific` mode, then this argument should be {result_folder}/kmer_only.tsv with {result_folder} passed under `--partitioned-tsv`. kmer_only.tsv will be created on the fly. \n \n 4. --mhc-alleles or --mhc-alleles-file: This argument should contain the alleles that will be used for the analysis of mhc binding affinity.\n \n ", required=True, default='')
    required.add_argument("--output-dir", help="General output file. Absolute path to the output directory to save the MHC predictions. It should match the directory provided in --output-csv of the argstring, but without the file name.", required=True, default='')

    optional = parser.add_argument_group('Optional argument')
    optional.add_argument("--partitioned-tsv", help="The input to this command is the path to the folder containing the partitioned tsv files from `cancerspecif` mode. The file partitions should be named part* with kmers in the first column and a tab separation. They can be in gzip format or not. If this parameter is set the tool will directly accept the files from cancerspecif mode as input.", required=False, default=None)
    optional.add_argument("--bind-score-method", help="Scoring method to filter the MHC tools predictions. E.g. score, affinity, percentile_rank (this last one is only for netmhcpan).", required=False, default=None)
    optional.add_argument("--bind-score-threshold", type=float, help="Threshold to filter the MHC tools predictions. All the peptides with a score lower than the threshold will be filtered out and only the ones with a score higher than the threshold will be kept.", required=False, default=None)
    optional.add_argument("--less-than", help="With this option set, the `--bind-score-threshold` will be considered as an upper bound instead of a lower bound. This means that peptides with a score higher than this threshold will be filtered out.", action="store_true", required=False, default=False)
    _add_general_args(parser)
    return parser

def get_pepquery_parser(parser):
    required = parser.add_argument_group('Mandatory arguments')
    required.add_argument("--output-dir", help="Absolute path to the output directory to save the results of the validation.", required=True, default=None)
    required.add_argument("--argstring", help="Complete command line for the pepQuery MS based validation software passed as a string. The command provided here will be directly passed to the pepQuery software. It must contain several mandatory arguments: \n 1. -o: Output directory. The results from pepQuery will be saved in this folder. \n 2. -i: Input peptides for the validation. The user can either provide their own peptides or take the expanded peptides from the kmers provided in --partitioned-tsv. If --partitioned-tsv is provided, the expanded peptides will be saved under the path and filename provided in this argument, and they will be taken as the input of pepQuery.\n 3. -db: Path to the reference database used in the analysis. This reference database will be used to identify those MS/MS spectra that match better a reference peptide than the query peptides. \n 4. -ms: Path to the MS/MS spectra file.", required=True, default=None)
    required.add_argument("--pepquery-software-path", help="Path for the pepQuery software. It must include the path to the directory with the software and the software name itself. eg. pepquery/pepquery.jar", required=True, default=None)

    optional = parser.add_argument_group('Optional argument')
    optional.add_argument("--partitioned-tsv", help="The input to this command is the path to the folder containing the partitioned tsv files from `cancerspecif` mode. If this parameter is set the tool will directly accept the files from cancerspecif mode as input. An intermediate file will be saved in the output directory containing the kmers in a bigger peptide context. This argument accepts files generated from junctions and from segments.", required=False, default=None)
    optional.add_argument("--metadata-path", help="Absolute path to the metadata file created in build mode. This file is required whether the user chooses to work with junctions of with kmers.", required=False, default=None)
    optional.add_argument("--kmer-type", help="Type of the kmers introduced under --partitioned-tsv. This will show whether the user chooses to work with junctions or with segments. The peptide retrieval strategy will vary depending on the input type.", choices=['junctions', 'segments'], required=False, default=None)
    _add_general_args(parser)
    return parser
def parse_arguments(argv):
    parser = argparse.ArgumentParser(prog='immunopepper')
    parser_build, parser_samplespecif, parser_cancerspecif, parser_mhcbind, parser_pepquery = get_subparsers(parser)

    #Now I will fill the different parsers with the arguments. I will create a function for each parser, and that will be the function displayed in the documentation part.

    parser_build = get_build_parser(parser_build)
    parser_samplespecif = get_samplespecif_parser(parser_samplespecif)
    parser_cancerspecif = get_cancerspecif_parser(parser_cancerspecif)
    parser_mhcbind = get_mhcbind_parser(parser_mhcbind)
    parser_pepquery = get_pepquery_parser(parser_pepquery)

    if len(argv) < 1:
        parser.print_help()
        sys.exit(1)

    if len(argv) < 2:
        if argv[0] == 'build':
            parser_build.print_help()
        elif argv[0] == 'samplespecif':
            parser_samplespecif.print_help()
        elif argv[0] == "cancerspecif":
            parser_cancerspecif.print_help()
        elif argv[0] == "mhcbind":
            sys.stdout.write("------------------------------ MHCBIND IMMUNOPEPPER USAGE ------------------------------ \n \n ")
            parser_mhcbind.print_help()
            sys.stdout.write("\n------------------------------ MHCTOOLS AVAILABLE COMMAND LINE OPTIONS ------------------------------ \n \n ")
            from mhctools.mhctools.cli.args import make_mhc_arg_parser
            parser_mhc = make_mhc_arg_parser(prog="mhctools",description=("Predict MHC ligands from protein sequences")) 
            parser_mhc.print_help()
        elif argv[0] == 'pepquery':
            sys.stdout.write("------------------------------ PEPQUERY IMMUNOPEPPER USAGE ------------------------------ \n \n ")
            parser_pepquery.print_help()
        else:
            parser.print_help()


    pargs = parser.parse_args(argv)
    return pargs

def split_mode(options):

    arg = parse_arguments(options)
    mode = options[0]
    if not os.path.isdir(arg.output_dir):
        os.makedirs(arg.output_dir)
    now = datetime.now()

    if arg.verbose > 0:
        stdout_handler = logging.StreamHandler(sys.stdout)
        handlers = [stdout_handler]
    ### set log level
    if arg.verbose == 0:
        log_level = logging.WARNING
    elif arg.verbose == 1:
        log_level = logging.INFO
    else:
        log_level = logging.DEBUG

    logging.basicConfig(
                         level=log_level,
                         handlers=handlers,
                         format="%(asctime)-15s %(levelname)-8s %(message)s")


    logging.info("Command line"+str(arg))
    if mode == 'build':
        pass
        mode_build(arg)
    if mode == 'samplespecif':
        pass
        mode_samplespecif(arg)
    if mode == "cancerspecif":
        pass
        mode_cancerspecif(arg)
    if mode == "mhcbind":
        pass
        from immunopepper.mode_mhcbind import mode_mhcbind #import here due to logging conflict
        mode_mhcbind(arg)
    if mode == 'pepquery':
        mode_pepquery(arg)

def cmd_entry():
    options = sys.argv[1:]
    split_mode(options)

if __name__ == "__main__":
    cmd_entry()

